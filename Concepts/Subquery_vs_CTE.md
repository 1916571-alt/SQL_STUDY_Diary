# 🧠 SQL 사고법: 서브쿼리(Subquery) vs CTE

SQL을 작성할 때 논리적 흐름을 중시하는 **CTE**와 결과 중심적인 **서브쿼리** 사이에서 고민하게 됩니다. 효율적인 쿼리 작성을 위한 4가지 핵심 가이드를 정리합니다.

---

## 1. "값 하나"가 필요할 땐 "상수"로 취급하라
평균값, 최대값 등 **단 하나의 숫자(Scalar)**를 비교 조건으로 쓸 때는 이를 별도의 테이블이 아닌 '변수'나 '상수'처럼 생각하는 것이 훨씬 간결합니다.

- **CTE 방식 (절차적 사고)**: "평균을 구한다 → 결과 테이블을 만든다 → 본 테이블과 조인하여 비교한다."
- **서브쿼리 방식 (결과 중심 사고)**: "내 연봉 > **(그 숫자)**"

> **Tip**: `WHERE` 절이나 `SELECT` 절에 숫자를 직접 적어야 할 자리에 괄호를 열고 `SELECT`를 넣는다고 생각하세요.

```sql
-- 서브쿼리가 훨씬 직관적인 예시
SELECT * 
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES); 
-- 괄호 안의 SELECT 자체가 하나의 '고정된 값' 역할을 합니다.
```

---

## 2. "존재 여부"를 물을 땐 JOIN 대신 `EXISTS`
"이 그룹에 데이터가 있는가?"를 확인할 때 CTE로 가상 테이블을 만들고 조인하는 것보다 `EXISTS`를 쓰는 것이 사고 장벽을 낮춰줍니다.

- **Tip**: 테이블을 "합친다"고 생각하지 말고, **"본 테이블의 각 행(row)을 들여다보며 O/X 퀴즈를 낸다"**고 생각하세요.

```sql
-- '주문 기록이 있는 고객'을 찾을 때
SELECT CUSTOMER_NAME
FROM CUSTOMERS C
WHERE EXISTS (
    SELECT 1 
    FROM ORDERS O 
    WHERE O.CUSTOMER_ID = C.CUSTOMER_ID
);
```
*`EXISTS`는 조건에 맞는 행을 하나라도 찾으면 즉시 검색을 멈추기 때문에 성능상으로도 유리합니다.*

---

## 3. "서랍 속 자료" vs "옆에 둔 메모지"
두 방식의 활용 용도를 도구에 비유하면 이해가 쉽습니다.

- **CTE (서랍)**: 대량의 데이터를 미리 가공해서 **여러 번 꺼내 써야 할 때** (구조적 설계)
- **서브쿼리 (메모지)**: 지금 당장 이 조건 하나를 확인하기 위해 **잠깐 결과만 빌려올 때** (즉각적 판단)

---

## 4. 가독성의 임계점: "다시 쓸 데이터인가?"
서브쿼리를 쓸지 CTE를 쓸지 결정하는 가장 명확한 기준(Rule of Thumb)은 **재사용성**입니다.

> **"내가 지금 이 가공된 데이터를 다른 조건에서도 또 써야 하는가?"**

- **No (단발성 모니터링)**: **서브쿼리**로 해결하여 코드를 컴팩트하게 유지하세요.
- **Yes (복합 로직)**: **CTE**를 사용하여 가독성과 유지보수성을 확보하세요.

---

## 💡 결론: Inside-Out 연습법
CTE는 위에서 아래로(Top-Down) 흐르지만, 서브쿼리는 안쪽에서 바깥쪽으로(Inside-Out) 확장됩니다.

1. `SELECT * FROM TABLE`을 먼저 작성한다.
2. `WHERE COL = ( )` 처럼 빈 괄호를 먼저 만든다.
3. 그 괄호 안에 들어갈 "단 하나의 정답"을 구하는 쿼리를 채워 넣는다.

이 흐름에 익숙해지면 불필요하게 복잡한 CTE 설계를 줄이고, 훨씬 엔진 친화적이고 간결한 SQL을 짤 수 있습니다.
