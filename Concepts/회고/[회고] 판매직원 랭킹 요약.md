# [회고] 판매직원 랭킹 요약

## 문제 요구사항

1. 판매 직원별 판매 대수 COUNT
2. 판매대수 내림차순으로 RANK
3. **1등은 동률이어도 모두 개별 ROW 반환**
4. **나머지 순위는 같은 RNK에 여러 명이면 "직원번호 최소인 사람 이름 + N OTHER PEOPLE" 형식으로 요약**
5. 출력: `판매대수, 직원명` (2개 컬럼)

---

## 가상 데이터베이스

```sql
-- 테이블 생성
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE sales (
    sale_id INT PRIMARY KEY,
    employee_id INT
);

-- 직원 데이터
INSERT INTO employees VALUES
(101, '김철수'),
(102, '이영희'),
(103, '박민수'),
(104, '최지훈'),
(105, '정수연'),
(106, '한동욱');

-- 판매 데이터 (각 행 = 1대 판매)
INSERT INTO sales VALUES
-- 김철수(101): 5대
(1, 101), (2, 101), (3, 101), (4, 101), (5, 101),
-- 이영희(102): 5대 (1등 동률)
(6, 102), (7, 102), (8, 102), (9, 102), (10, 102),
-- 박민수(103): 3대
(11, 103), (12, 103), (13, 103),
-- 최지훈(104): 3대 (동률)
(14, 104), (15, 104), (16, 104),
-- 정수연(105): 3대 (동률)
(17, 105), (18, 105), (19, 105),
-- 한동욱(106): 2대
(20, 106), (21, 106);
```

### 예상 결과

| SALES_COUNT | EMPLOYEE_INFO |
|-------------|---------------|
| 5 | 김철수 |
| 5 | 이영희 |
| 3 | 박민수 + 2 OTHER PEOPLE |
| 2 | 한동욱 |

---

## 내가 시도한 접근 (4단계 CTE)

```sql
-- Step 1: 직원별 세일즈 추출
WITH employee_sales AS (
    SELECT
        e.employee_id,
        e.name,
        COUNT(*) AS sales_count
    FROM employees e
    JOIN sales s ON e.employee_id = s.employee_id
    GROUP BY e.employee_id, e.name
),

-- Step 2: 랭킹
ranked AS (
    SELECT
        employee_id,
        name,
        sales_count,
        RANK() OVER (ORDER BY sales_count DESC) AS rnk
    FROM employee_sales
),

-- Step 3: 1등 추출
top_rank AS (
    SELECT sales_count, name
    FROM ranked
    WHERE rnk = 1
),

-- Step 4: 1등 제외 나머지 추출
other_ranks AS (
    SELECT
        sales_count,
        CASE
            WHEN COUNT(*) > 1
            THEN CONCAT(name, ' + ', COUNT(*) - 1, ' OTHER PEOPLE')
            ELSE name
        END AS name
    FROM ranked
    WHERE rnk > 1
    GROUP BY rnk
)

SELECT * FROM top_rank
UNION ALL
SELECT * FROM other_ranks
ORDER BY sales_count DESC;
```

---

## 발생한 문제

### 증상
- `top_rank`, `other_ranks` **개별 실행 시 정상**
- **UNION ALL 하니까 행 수가 비정상적으로 증가**
- `N OTHER PEOPLE` 표시도 이상하게 나옴

### 원인: GROUP BY에 없는 컬럼 사용

```sql
other_ranks AS (
    SELECT
        sales_count,  -- ← GROUP BY에 없음!
        CONCAT(name, ...)  -- ← GROUP BY에 없음!
    FROM ranked
    WHERE rnk > 1
    GROUP BY rnk  -- ← rnk만 그룹화
)
```

**SQL 표준에서는 에러**지만, MySQL의 `ONLY_FULL_GROUP_BY` 모드가 꺼져 있으면:
- 에러 없이 실행됨
- **그룹 내 임의의 값**이 선택됨
- CTE를 UNION으로 합칠 때 **예측 불가능한 동작** 발생

### 왜 개별 실행은 괜찮았나?

개별로 `SELECT * FROM other_ranks`를 실행하면 우연히 맞아 보일 수 있음.
하지만 UNION으로 합치면서 SQL 엔진 내부 최적화가 달라지고,
**임의 값 선택이 다르게 동작**해서 결과가 망가짐.

---

## 문제점 상세 분석

### 1. sales_count 집계 누락

```sql
SELECT sales_count  -- GROUP BY에 없음
GROUP BY rnk
```

같은 rnk면 sales_count도 같지만, **명시적으로 집계해야 안전**

**수정**: `MAX(sales_count)` 사용

---

### 2. name 집계 누락 + 잘못된 선택

```sql
CONCAT(name, ' + ', COUNT(*) - 1, ' OTHER PEOPLE')
```

- `name`이 GROUP BY에 없어서 **임의의 이름** 선택됨
- 조건은 "직원번호 최소인 사람"인데 이 로직이 없음

**수정**: `MIN(employee_id)` 찾고 JOIN으로 name 가져오기

---

### 3. UNION 시 불안정성

CTE 안에서 불안정한 쿼리를 UNION하면:
- SQL 엔진 최적화에 따라 결과가 달라짐
- 개별 실행과 UNION 실행 결과가 다를 수 있음

---

## 권장 풀이 방법

### 핵심 원칙
1. **GROUP BY에 없는 컬럼은 반드시 집계 함수로 감싸기**
2. **특정 행의 값을 가져오려면 서브쿼리 또는 JOIN 사용**
3. **UNION 전에 각 SELECT의 안정성 확보**

---

### 방법 1: 안전한 4단계 CTE (UNION 방식)

```sql
WITH employee_sales AS (
    SELECT
        e.employee_id,
        e.name,
        COUNT(*) AS sales_count
    FROM employees e
    JOIN sales s ON e.employee_id = s.employee_id
    GROUP BY e.employee_id, e.name
),

ranked AS (
    SELECT
        employee_id,
        name,
        sales_count,
        RANK() OVER (ORDER BY sales_count DESC) AS rnk
    FROM employee_sales
),

-- 순위별 요약 (안전하게 집계)
rank_summary AS (
    SELECT
        rnk,
        MAX(sales_count) AS sales_count,
        COUNT(*) AS people_count,
        MIN(employee_id) AS min_employee_id
    FROM ranked
    GROUP BY rnk
),

-- 최소 직원번호의 이름 가져오기
rank_with_name AS (
    SELECT
        rs.rnk,
        rs.sales_count,
        rs.people_count,
        r.name AS first_employee_name
    FROM rank_summary rs
    JOIN ranked r ON rs.min_employee_id = r.employee_id
)

-- 1등: 개별 ROW
SELECT sales_count, name AS employee_info
FROM ranked
WHERE rnk = 1

UNION ALL

-- 나머지: 요약
SELECT
    sales_count,
    CASE
        WHEN people_count > 1
        THEN CONCAT(first_employee_name, ' + ', people_count - 1, ' OTHER PEOPLE')
        ELSE first_employee_name
    END AS employee_info
FROM rank_with_name
WHERE rnk > 1

ORDER BY sales_count DESC;
```

---

### 방법 2: UNION 없이 단일 쿼리 (더 간결)

```sql
WITH employee_sales AS (
  SELECT
    e.employee_id,
    e.name,
    COUNT(*) AS sales_count
  FROM employees e
  JOIN sales s
    ON s.employee_id = e.employee_id
  GROUP BY e.employee_id, e.name
),
ranked_base AS (
  SELECT
    employee_id,
    name,
    sales_count,
    RANK() OVER (ORDER BY sales_count DESC) AS rnk
  FROM employee_sales
),
ranked AS (
  SELECT
    employee_id,
    name,
    sales_count,
    rnk,
    COUNT(*) OVER (PARTITION BY rnk) AS same_rank_count,
    ROW_NUMBER() OVER (
      PARTITION BY rnk
      ORDER BY employee_id
    ) AS rn_in_rank
  FROM ranked_base
)
SELECT
  sales_count,
  CASE
    -- 1등: 동점자 전원 개별 출력
    WHEN rnk = 1 THEN name

    -- 2등 이하: 동점이면 대표 1명만 " + n OTHER PEOPLE"
    WHEN rn_in_rank = 1 AND same_rank_count > 1
      THEN CONCAT(name, ' + ', same_rank_count - 1, ' OTHER PEOPLE')

    -- 2등 이하: 단독이면 그냥 출력
    WHEN rn_in_rank = 1
      THEN name
  END AS employee_info
FROM ranked
WHERE rnk = 1 OR rn_in_rank = 1
ORDER BY sales_count DESC, employee_info;


**장점**: UNION 없이 윈도우 함수로 한 번에 처리

---

### 방법 3: 가장 직관적인 방식 (서브쿼리 활용)

```sql
WITH employee_sales AS (
    SELECT
        e.employee_id,
        e.name,
        COUNT(*) AS sales_count
    FROM employees e
    JOIN sales s ON e.employee_id = s.employee_id
    GROUP BY e.employee_id, e.name
),

ranked AS (
    SELECT
        employee_id,
        name,
        sales_count,
        RANK() OVER (ORDER BY sales_count DESC) AS rnk
    FROM employee_sales
)

-- 1등 개별 출력
SELECT sales_count, name AS employee_info
FROM ranked
WHERE rnk = 1

UNION ALL

-- 나머지 순위별 1행씩
SELECT
    sales_count,
    CASE
        WHEN (SELECT COUNT(*) FROM ranked r2 WHERE r2.rnk = r.rnk) > 1
        THEN CONCAT(
            name,
            ' + ',
            (SELECT COUNT(*) - 1 FROM ranked r2 WHERE r2.rnk = r.rnk),
            ' OTHER PEOPLE'
        )
        ELSE name
    END AS employee_info
FROM ranked r
WHERE rnk > 1
  AND employee_id = (SELECT MIN(employee_id) FROM ranked r2 WHERE r2.rnk = r.rnk)

ORDER BY sales_count DESC;
```

**장점**: GROUP BY 없이 서브쿼리로 명확하게 처리

---

## 핵심 교훈

| 실수 | 원인 | 해결책 |
|------|------|--------|
| GROUP BY 없이 컬럼 사용 | SQL 모드에 따라 임의 값 선택 | **반드시 집계 함수로 감싸기** |
| 특정 행의 값 가져오기 | GROUP BY로는 불가능 | **MIN(id) + JOIN** 또는 **서브쿼리** |
| UNION 시 결과 불안정 | 개별 CTE가 불안정하면 합쳐도 불안정 | **각 SELECT 안정성 먼저 확보** |

---

## 실행 결과

```
+-------------+-----------------------------+
| sales_count | employee_info               |
+-------------+-----------------------------+
|           5 | 김철수                       |
|           5 | 이영희                       |
|           3 | 박민수 + 2 OTHER PEOPLE      |
|           2 | 한동욱                       |
+-------------+-----------------------------+
```
