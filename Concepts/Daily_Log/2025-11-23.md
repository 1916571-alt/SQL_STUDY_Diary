# 📅 2025-11-23 SQL Study Log
> **Platform**: Programmers
> **Topic**: GROUP BY, JOIN, String Functions

---

## 1. 조건에 맞는 사원 정보 조회하기 (Level 2)
[Programmers Link](https://school.programmers.co.kr/learn/courses/30/lessons/284527)

### ❌ Initial Approach (Mistake)
단순히 `LIMIT 1`만 사용하면 전체 합계가 아닌 개별 행만 가져오게 됨.
```sql
SELECT g.SCORE, e.EMP_NO ...
ORDER BY g.SCORE DESC
LIMIT 1
```

### ✅ Correction
`SCORE`를 연도별/사원별로 합산해야 하므로 `GROUP BY` 필수.

```sql
WITH base as(
    SELECT EMP_NO, YEAR, SUM(SCORE) AS SCORE_1
    FROM HR_GRADE
    GROUP BY EMP_NO, YEAR
)
SELECT SUM(b.SCORE_1) AS SCORE, b.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
FROM base b
JOIN HR_EMPLOYEES e ON b.EMP_NO = e.EMP_NO
GROUP BY b.EMP_NO
ORDER BY SCORE DESC
LIMIT 1;
```

---

## 2. 노선별 평균 역 사이 거리 조회하기
[Programmers Link](https://school.programmers.co.kr/learn/courses/30/lessons/284531)

### 🚨 Learning Point
`CONCAT`으로 문자열("km")이 붙은 컬럼을 `ORDER BY`에 쓰면 **사전순 정렬**(10km < 2km)이 되어버린다.

**Correct Way**: `ORDER BY`에는 반드시 **원본 수치 계산식**을 써야 한다.

```sql
SELECT ROUTE,
    CONCAT(ROUND(SUM(D_BETWEEN_DIST), 1), 'km') AS TOTAL_DISTANCE,
    CONCAT(ROUND(AVG(D_BETWEEN_DIST), 2), 'km') AS AVERAGE_DISTANCE
FROM SUBWAY_DISTANCE
GROUP BY ROUTE
ORDER BY SUM(D_BETWEEN_DIST) DESC; -- 숫자 기준으로 정렬
```

---

## 3. 자동차 대여 기록 판별 (Level 4)

### 🔥 핵심 패턴: MAX(CASE WHEN)

> **Q. 그룹 내에서 조건을 만족하는 row가 하나라도 있으면 '대여중'인가?**
> **A.** `MAX(CASE WHEN ... THEN 1 ELSE 0 END)` 패턴 사용.

```sql
SELECT
    CAR_ID,
    CASE
        WHEN MAX(CASE WHEN '2022-10-16' BETWEEN START_DATE AND END_DATE THEN 1 ELSE 0 END) > 0
        THEN '대여중'
        ELSE '대여 가능'
    END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC;
```

---

## 4. 기타 문제 요약

- **즐겨찾기가 가장 많은 식당**: `GROUP BY`로 MAX값을 구한 뒤 원본 테이블과 `JOIN` 하는 패턴.
- **부서별 평균 연봉**: `ROUND(AVG(SAL), 0)` 활용.
