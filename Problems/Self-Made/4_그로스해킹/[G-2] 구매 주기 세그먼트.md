# 구매 주기 세그먼트

> **정보**
> - **날짜**: 2026년 01월 21일
> - **분류**: Self-Made (G-2)
> - **주제**: 세그먼트 분류
> - **난이도**: ★★★
> - **재풀이 여부**: X

---

### 문제 설명

평균 구매 주기를 기반으로 고객을 세그먼트화하세요.

**테이블**: orders

**출력**: purchase_segment | customer_count | segment_avg_cycle

---

### 정답 풀이

```sql
WITH order_gaps AS (
    SELECT
        user_id,
        DATEDIFF(order_date,
            LAG(order_date) OVER (PARTITION BY user_id ORDER BY order_date)
        ) AS days_between
    FROM orders
),
avg_cycle AS (
    SELECT
        user_id,
        ROUND(AVG(days_between), 1) AS avg_purchase_cycle
    FROM order_gaps
    WHERE days_between IS NOT NULL
    GROUP BY user_id
)
SELECT
    CASE
        WHEN avg_purchase_cycle <= 7 THEN '매주 구매 (Weekly)'
        WHEN avg_purchase_cycle <= 14 THEN '2주 구매 (Bi-weekly)'
        WHEN avg_purchase_cycle <= 30 THEN '월간 구매 (Monthly)'
        WHEN avg_purchase_cycle <= 90 THEN '분기 구매 (Quarterly)'
        ELSE '비정기 구매 (Occasional)'
    END AS purchase_segment,
    COUNT(*) AS customer_count,
    ROUND(AVG(avg_purchase_cycle), 1) AS segment_avg_cycle
FROM avg_cycle
GROUP BY
    CASE
        WHEN avg_purchase_cycle <= 7 THEN '매주 구매 (Weekly)'
        WHEN avg_purchase_cycle <= 14 THEN '2주 구매 (Bi-weekly)'
        WHEN avg_purchase_cycle <= 30 THEN '월간 구매 (Monthly)'
        WHEN avg_purchase_cycle <= 90 THEN '분기 구매 (Quarterly)'
        ELSE '비정기 구매 (Occasional)'
    END
ORDER BY segment_avg_cycle;
```

---

### 핵심 포인트

1. **CASE로 세그먼트 분류**: 연속형 → 범주형 변환
2. **세그먼트 기준**: 비즈니스에 맞게 조정 가능 (7일, 14일 등)
3. **마케팅 활용**: 세그먼트별 다른 리마인더 타이밍 설정
