# 세션 분석

> **정보**
> - **날짜**: 2026년 01월 23일
> - **분류**: Self-Made (X-2)
> - **주제**: 30분 기준 세션 분리 및 분석
> - **난이도**: ★★★★
> - **재풀이 여부**: X

---

### 문제 설명

앱 이벤트 로그를 분석하여 세션을 정의하고 세션별 통계를 계산하세요.
**세션 정의**: 동일 사용자의 이벤트 중 30분 이상 간격이 있으면 새 세션

**테이블**: app_logs
| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| id | INT | 로그 ID |
| user_id | INT | 사용자 ID |
| event_name | VARCHAR | 이벤트명 |
| event_date | DATE | 이벤트 날짜 |
| event_time | TIME | 이벤트 시간 |

**출력**: user_id | session_id | session_start | session_end | duration_min | event_count | has_purchase

---

### 정답 풀이

```sql
WITH events_with_time AS (
    SELECT
        id,
        user_id,
        event_name,
        TIMESTAMP(event_date, event_time) AS event_datetime
    FROM app_logs
),
event_gaps AS (
    SELECT
        id,
        user_id,
        event_name,
        event_datetime,
        LAG(event_datetime) OVER (
            PARTITION BY user_id
            ORDER BY event_datetime
        ) AS prev_event_time,
        TIMESTAMPDIFF(MINUTE,
            LAG(event_datetime) OVER (
                PARTITION BY user_id
                ORDER BY event_datetime
            ),
            event_datetime
        ) AS minutes_gap
    FROM events_with_time
),
session_flags AS (
    SELECT
        id,
        user_id,
        event_name,
        event_datetime,
        CASE
            WHEN prev_event_time IS NULL THEN 1
            WHEN minutes_gap >= 30 THEN 1
            ELSE 0
        END AS is_new_session
    FROM event_gaps
),
session_ids AS (
    SELECT
        id,
        user_id,
        event_name,
        event_datetime,
        SUM(is_new_session) OVER (
            PARTITION BY user_id
            ORDER BY event_datetime
            ROWS UNBOUNDED PRECEDING
        ) AS session_num
    FROM session_flags
)
SELECT
    user_id,
    CONCAT(user_id, '-', session_num) AS session_id,
    MIN(event_datetime) AS session_start,
    MAX(event_datetime) AS session_end,
    TIMESTAMPDIFF(MINUTE, MIN(event_datetime), MAX(event_datetime)) AS duration_min,
    COUNT(*) AS event_count,
    MAX(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS has_purchase
FROM session_ids
GROUP BY user_id, session_num
ORDER BY user_id, session_start;
```

---

### 세션 통계 요약

```sql
WITH events_with_time AS (
    SELECT
        user_id,
        event_name,
        TIMESTAMP(event_date, event_time) AS event_datetime
    FROM app_logs
),
session_flags AS (
    SELECT
        user_id,
        event_name,
        event_datetime,
        CASE
            WHEN LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime) IS NULL THEN 1
            WHEN TIMESTAMPDIFF(MINUTE,
                LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime),
                event_datetime) >= 30 THEN 1
            ELSE 0
        END AS new_session
    FROM events_with_time
),
sessions AS (
    SELECT
        user_id,
        event_name,
        event_datetime,
        SUM(new_session) OVER (PARTITION BY user_id ORDER BY event_datetime) AS session_num
    FROM session_flags
),
session_stats AS (
    SELECT
        user_id,
        session_num,
        MIN(event_datetime) AS start_time,
        MAX(event_datetime) AS end_time,
        COUNT(*) AS events,
        MAX(CASE WHEN event_name = 'purchase' THEN 1 ELSE 0 END) AS converted
    FROM sessions
    GROUP BY user_id, session_num
)
SELECT
    COUNT(*) AS total_sessions,
    COUNT(DISTINCT user_id) AS unique_users,
    ROUND(AVG(events), 1) AS avg_events_per_session,
    ROUND(AVG(TIMESTAMPDIFF(MINUTE, start_time, end_time)), 1) AS avg_duration_min,
    SUM(converted) AS converted_sessions,
    ROUND(SUM(converted) * 100.0 / COUNT(*), 2) AS session_conversion_rate
FROM session_stats;
```

---

### 세션 내 이벤트 시퀀스 분석

```sql
WITH events_with_time AS (
    SELECT
        user_id,
        event_name,
        TIMESTAMP(event_date, event_time) AS event_datetime
    FROM app_logs
),
session_flags AS (
    SELECT
        user_id,
        event_name,
        event_datetime,
        CASE
            WHEN LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime) IS NULL THEN 1
            WHEN TIMESTAMPDIFF(MINUTE,
                LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime),
                event_datetime) >= 30 THEN 1
            ELSE 0
        END AS new_session
    FROM events_with_time
),
sessions AS (
    SELECT
        user_id,
        event_name,
        event_datetime,
        SUM(new_session) OVER (PARTITION BY user_id ORDER BY event_datetime) AS session_num,
        ROW_NUMBER() OVER (PARTITION BY user_id, SUM(new_session) OVER (PARTITION BY user_id ORDER BY event_datetime) ORDER BY event_datetime) AS event_order
    FROM session_flags
),
session_paths AS (
    SELECT
        user_id,
        session_num,
        GROUP_CONCAT(event_name ORDER BY event_order SEPARATOR ' > ') AS event_path
    FROM sessions
    GROUP BY user_id, session_num
)
SELECT
    event_path,
    COUNT(*) AS session_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS path_percentage
FROM session_paths
GROUP BY event_path
ORDER BY session_count DESC
LIMIT 20;
```

---

### 시간대별 세션 분포

```sql
WITH events_with_time AS (
    SELECT
        user_id,
        TIMESTAMP(event_date, event_time) AS event_datetime
    FROM app_logs
),
session_starts AS (
    SELECT
        user_id,
        event_datetime,
        CASE
            WHEN LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime) IS NULL THEN 1
            WHEN TIMESTAMPDIFF(MINUTE,
                LAG(event_datetime) OVER (PARTITION BY user_id ORDER BY event_datetime),
                event_datetime) >= 30 THEN 1
            ELSE 0
        END AS is_start
    FROM events_with_time
)
SELECT
    HOUR(event_datetime) AS hour_of_day,
    COUNT(*) AS session_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS percentage
FROM session_starts
WHERE is_start = 1
GROUP BY HOUR(event_datetime)
ORDER BY hour_of_day;
```

---

### 핵심 포인트

1. **TIMESTAMP 생성**: `TIMESTAMP(event_date, event_time)` 또는 `CONCAT`
2. **LAG로 간격 계산**: 이전 이벤트와의 시간 차이
3. **30분 기준 플래그**: 간격 >= 30분이면 새 세션 시작
4. **누적합 세션ID**: `SUM(flag) OVER (ORDER BY ...)` 패턴
5. **GROUP_CONCAT**: 세션 내 이벤트 경로 문자열화

---

### 실무 활용

- 사용자 행동 패턴 분석
- 세션당 전환율 계산
- 평균 세션 길이 트래킹
- 이탈 지점 파악 (세션 종료 직전 이벤트)
