# 연속 로그인 보상

> **정보**
> - **날짜**: 2026년 01월 23일
> - **분류**: Self-Made (X-1)
> - **주제**: 연속 패턴 탐지 + 구간 분석
> - **난이도**: ★★★★
> - **재풀이 여부**: X

---

### 문제 설명

연속 로그인 일수를 계산하고, 보상 기준에 따라 사용자별 획득 보상을 산정하세요.

**보상 기준**:
- 3일 연속: 100 포인트
- 7일 연속: 500 포인트
- 14일 연속: 1500 포인트
- 30일 연속: 5000 포인트

**테이블**: login_logs
| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| id | INT | ID |
| user_id | INT | 사용자 ID |
| login_date | DATE | 로그인 날짜 |

**출력**: user_id | streak_start | streak_end | streak_days | reward_points

---

### 정답 풀이

```sql
WITH daily_logins AS (
    SELECT DISTINCT user_id, login_date
    FROM login_logs
),
streak_groups AS (
    SELECT
        user_id,
        login_date,
        -- 연속된 날짜는 같은 그룹이 됨
        DATE_SUB(login_date, INTERVAL ROW_NUMBER() OVER (
            PARTITION BY user_id
            ORDER BY login_date
        ) DAY) AS streak_group
    FROM daily_logins
),
streaks AS (
    SELECT
        user_id,
        streak_group,
        MIN(login_date) AS streak_start,
        MAX(login_date) AS streak_end,
        COUNT(*) AS streak_days
    FROM streak_groups
    GROUP BY user_id, streak_group
)
SELECT
    user_id,
    streak_start,
    streak_end,
    streak_days,
    CASE
        WHEN streak_days >= 30 THEN 5000
        WHEN streak_days >= 14 THEN 1500
        WHEN streak_days >= 7 THEN 500
        WHEN streak_days >= 3 THEN 100
        ELSE 0
    END AS reward_points
FROM streaks
WHERE streak_days >= 3
ORDER BY user_id, streak_start;
```

---

### 누적 보상 계산 (중첩 보상)

```sql
WITH daily_logins AS (
    SELECT DISTINCT user_id, login_date
    FROM login_logs
),
streak_groups AS (
    SELECT
        user_id,
        login_date,
        DATE_SUB(login_date, INTERVAL ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        ) DAY) AS grp
    FROM daily_logins
),
streaks AS (
    SELECT
        user_id,
        MIN(login_date) AS streak_start,
        MAX(login_date) AS streak_end,
        COUNT(*) AS streak_days
    FROM streak_groups
    GROUP BY user_id, grp
),
rewards_calc AS (
    SELECT
        user_id,
        streak_start,
        streak_end,
        streak_days,
        -- 누적 보상: 각 마일스톤 도달 시 보상 획득
        (CASE WHEN streak_days >= 3 THEN 100 ELSE 0 END) +
        (CASE WHEN streak_days >= 7 THEN 500 ELSE 0 END) +
        (CASE WHEN streak_days >= 14 THEN 1500 ELSE 0 END) +
        (CASE WHEN streak_days >= 30 THEN 5000 ELSE 0 END) AS total_reward
    FROM streaks
)
SELECT
    user_id,
    streak_start,
    streak_end,
    streak_days,
    total_reward AS reward_points
FROM rewards_calc
ORDER BY user_id, streak_start;
```

---

### 사용자별 최장 연속 기록

```sql
WITH daily_logins AS (
    SELECT DISTINCT user_id, login_date
    FROM login_logs
),
streak_groups AS (
    SELECT
        user_id,
        login_date,
        DATE_SUB(login_date, INTERVAL ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        ) DAY) AS grp
    FROM daily_logins
),
streaks AS (
    SELECT
        user_id,
        MIN(login_date) AS streak_start,
        MAX(login_date) AS streak_end,
        COUNT(*) AS streak_days
    FROM streak_groups
    GROUP BY user_id, grp
),
max_streaks AS (
    SELECT
        user_id,
        MAX(streak_days) AS max_streak,
        COUNT(*) AS total_streaks
    FROM streaks
    GROUP BY user_id
)
SELECT
    s.user_id,
    u.name,
    s.streak_start,
    s.streak_end,
    s.streak_days,
    ms.total_streaks AS total_streak_count
FROM streaks s
JOIN max_streaks ms ON s.user_id = ms.user_id AND s.streak_days = ms.max_streak
JOIN users u ON s.user_id = u.id
ORDER BY s.streak_days DESC, s.user_id;
```

---

### 현재 진행 중인 연속 로그인

```sql
WITH daily_logins AS (
    SELECT DISTINCT user_id, login_date
    FROM login_logs
),
streak_groups AS (
    SELECT
        user_id,
        login_date,
        DATE_SUB(login_date, INTERVAL ROW_NUMBER() OVER (
            PARTITION BY user_id ORDER BY login_date
        ) DAY) AS grp
    FROM daily_logins
),
current_streaks AS (
    SELECT
        user_id,
        MIN(login_date) AS streak_start,
        MAX(login_date) AS streak_end,
        COUNT(*) AS streak_days
    FROM streak_groups
    GROUP BY user_id, grp
    HAVING MAX(login_date) >= DATE_SUB(CURDATE(), INTERVAL 1 DAY)
)
SELECT
    user_id,
    streak_start,
    streak_end,
    streak_days,
    CASE
        WHEN streak_days >= 30 THEN '30일 달성!'
        WHEN streak_days >= 14 THEN CONCAT(30 - streak_days, '일 후 30일 보상')
        WHEN streak_days >= 7 THEN CONCAT(14 - streak_days, '일 후 14일 보상')
        WHEN streak_days >= 3 THEN CONCAT(7 - streak_days, '일 후 7일 보상')
        ELSE CONCAT(3 - streak_days, '일 후 3일 보상')
    END AS next_milestone
FROM current_streaks
ORDER BY streak_days DESC;
```

---

### 핵심 포인트

1. **ROW_NUMBER 차감 기법**: `date - ROW_NUMBER() DAY` → 연속 날짜는 같은 값
2. **DISTINCT 처리**: 하루 여러 번 로그인 중복 제거
3. **그룹별 집계**: streak_group으로 연속 구간 그룹핑
4. **마일스톤 보상**: CASE WHEN으로 구간별 보상 산정
5. **현재 진행 중**: 오늘 또는 어제 로그인한 연속 기록

---

### 실무 활용

- 게임/앱 연속 접속 보상 시스템
- 출석 체크 이벤트
- 사용자 engagement 지표 분석
- 이탈 예측 (연속 기록 끊긴 사용자)
