# 계층 구조 탐색

> **정보**
> - **날짜**: 2026년 01월 23일
> - **분류**: Self-Made (X-3)
> - **주제**: 재귀 CTE를 활용한 조직도/카테고리 탐색
> - **난이도**: ★★★★
> - **재풀이 여부**: X

---

### 문제 설명

직원 테이블에서 재귀 CTE를 사용하여 조직 계층 구조를 탐색하세요.
각 직원의 계층 깊이, 관리 경로, 부하 직원 수를 계산합니다.

**테이블**: employees
| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| id | INT | 직원 ID |
| name | VARCHAR | 직원명 |
| dept_id | INT | 부서 ID |
| salary | INT | 연봉 |
| hire_date | DATE | 입사일 |
| manager_id | INT | 상사 ID (NULL이면 최상위) |

**출력**: emp_id | emp_name | depth | hierarchy_path | subordinate_count

---

### 정답 풀이

```sql
WITH RECURSIVE org_hierarchy AS (
    -- Base Case: 최상위 관리자 (manager_id IS NULL)
    SELECT
        id AS emp_id,
        name AS emp_name,
        manager_id,
        0 AS depth,
        CAST(name AS CHAR(500)) AS hierarchy_path,
        CAST(LPAD(id, 5, '0') AS CHAR(100)) AS sort_path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive Case: 부하 직원들
    SELECT
        e.id,
        e.name,
        e.manager_id,
        oh.depth + 1,
        CONCAT(oh.hierarchy_path, ' > ', e.name),
        CONCAT(oh.sort_path, '-', LPAD(e.id, 5, '0'))
    FROM employees e
    INNER JOIN org_hierarchy oh ON e.manager_id = oh.emp_id
),
subordinate_counts AS (
    -- 각 직원 아래의 모든 부하 직원 수 계산
    SELECT
        oh1.emp_id,
        COUNT(oh2.emp_id) AS subordinate_count
    FROM org_hierarchy oh1
    LEFT JOIN org_hierarchy oh2
        ON oh2.sort_path LIKE CONCAT(oh1.sort_path, '-%')
    GROUP BY oh1.emp_id
)
SELECT
    oh.emp_id,
    oh.emp_name,
    oh.depth,
    oh.hierarchy_path,
    sc.subordinate_count
FROM org_hierarchy oh
LEFT JOIN subordinate_counts sc ON oh.emp_id = sc.emp_id
ORDER BY oh.sort_path;
```

---

### 팀 전체 연봉 합계 포함

```sql
WITH RECURSIVE org_tree AS (
    SELECT
        id,
        name,
        salary,
        manager_id,
        0 AS depth,
        CAST(LPAD(id, 5, '0') AS CHAR(200)) AS path
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    SELECT
        e.id,
        e.name,
        e.salary,
        e.manager_id,
        ot.depth + 1,
        CONCAT(ot.path, '-', LPAD(e.id, 5, '0'))
    FROM employees e
    JOIN org_tree ot ON e.manager_id = ot.id
),
team_salary AS (
    SELECT
        t1.id AS manager_id,
        t1.salary + COALESCE(SUM(t2.salary), 0) AS team_total_salary
    FROM org_tree t1
    LEFT JOIN org_tree t2 ON t2.path LIKE CONCAT(t1.path, '-%')
    GROUP BY t1.id, t1.salary
)
SELECT
    ot.id AS emp_id,
    ot.name,
    ot.depth,
    ot.salary AS individual_salary,
    ts.team_total_salary,
    (SELECT COUNT(*) FROM org_tree WHERE path LIKE CONCAT(ot.path, '-%')) AS team_size
FROM org_tree ot
JOIN team_salary ts ON ot.id = ts.manager_id
ORDER BY ot.path;
```

---

### 특정 직원의 모든 상위 관리자 찾기

```sql
WITH RECURSIVE managers AS (
    -- 시작점: 특정 직원
    SELECT
        id,
        name,
        manager_id,
        0 AS level_up
    FROM employees
    WHERE id = 10  -- 조회할 직원 ID

    UNION ALL

    -- 상위 관리자 탐색
    SELECT
        e.id,
        e.name,
        e.manager_id,
        m.level_up + 1
    FROM employees e
    JOIN managers m ON e.id = m.manager_id
)
SELECT
    id AS manager_id,
    name AS manager_name,
    level_up AS levels_above
FROM managers
WHERE level_up > 0
ORDER BY level_up;
```

---

### 카테고리 계층 구조 (상품 카테고리 예시)

```sql
-- 카테고리 테이블이 있다고 가정
-- categories (id, name, parent_id)

WITH RECURSIVE category_tree AS (
    SELECT
        id,
        name,
        parent_id,
        0 AS depth,
        CAST(name AS CHAR(500)) AS full_path
    FROM categories
    WHERE parent_id IS NULL

    UNION ALL

    SELECT
        c.id,
        c.name,
        c.parent_id,
        ct.depth + 1,
        CONCAT(ct.full_path, ' > ', c.name)
    FROM categories c
    JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT
    id,
    CONCAT(REPEAT('  ', depth), name) AS indented_name,
    depth,
    full_path
FROM category_tree
ORDER BY full_path;
```

---

### 부서별 조직 구조

```sql
WITH RECURSIVE dept_org AS (
    SELECT
        e.id,
        e.name,
        e.dept_id,
        e.manager_id,
        0 AS depth,
        CAST(e.name AS CHAR(300)) AS chain
    FROM employees e
    WHERE e.manager_id IS NULL

    UNION ALL

    SELECT
        e.id,
        e.name,
        e.dept_id,
        e.manager_id,
        do.depth + 1,
        CONCAT(do.chain, ' > ', e.name)
    FROM employees e
    JOIN dept_org do ON e.manager_id = do.id
)
SELECT
    d.name AS department,
    do.name AS employee_name,
    do.depth,
    do.chain AS reporting_chain
FROM dept_org do
JOIN departments d ON do.dept_id = d.id
ORDER BY d.name, do.depth, do.name;
```

---

### 핵심 포인트

1. **WITH RECURSIVE 구문**: Base Case + UNION ALL + Recursive Case
2. **Base Case**: 재귀 시작점 (보통 parent IS NULL)
3. **Recursive Case**: 자기 참조 JOIN으로 하위 레벨 탐색
4. **CAST 필수**: 재귀 시 문자열 길이 확보
5. **정렬용 경로**: LPAD로 숫자 패딩하여 문자열 정렬 보장
6. **LIKE 패턴**: 서브트리 탐색에 경로 문자열 활용

---

### 실무 활용

- 조직도 시각화 데이터 생성
- 권한 관리 (상위 관리자 권한 상속)
- 카테고리/폴더 구조 탐색
- BOM(Bill of Materials) 분석
- 댓글의 대댓글 구조 표시
