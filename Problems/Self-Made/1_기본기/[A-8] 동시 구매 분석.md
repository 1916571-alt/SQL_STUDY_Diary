# 동시 구매 분석

> **정보**
> - **날짜**: 2026년 01월 21일
> - **분류**: Self-Made (A-8)
> - **주제**: Self JOIN
> - **난이도**: ★★★
> - **재풀이 여부**: X

---

### 문제 설명

상품 A(id=1)와 같은 주문에서 함께 구매된 상품들을 동시 구매 횟수가 많은 순으로 상위 10개 출력하세요.

**테이블**: order_items (id, order_id, product_id, quantity), products (id, name)

**출력**: product_name | co_purchase_count

---

### 정답 풀이

```sql
SELECT p.name AS product_name,
       COUNT(*) AS co_purchase_count
FROM order_items oi1
JOIN order_items oi2 ON oi1.order_id = oi2.order_id
JOIN products p ON oi2.product_id = p.id
WHERE oi1.product_id = 1
  AND oi2.product_id != 1
GROUP BY oi2.product_id, p.name
ORDER BY co_purchase_count DESC
LIMIT 10;
```

---

### Self JOIN 상세 설명

#### 1단계: 문제 파악

"상품 1과 같은 주문에서 함께 구매된 상품"을 찾아야 한다. 어떤 고객이 상품 1을 샀을 때 그 주문서에 같이 담긴 다른 상품들이 뭔지 알고 싶은 것.

#### 2단계: 왜 Self JOIN인가?

order_items 테이블 하나로는 "같은 주문의 다른 상품"을 찾을 수 없다. 한 행에는 하나의 상품 정보만 있기 때문. 그래서 같은 테이블을 두 번 불러와서 비교해야 한다:
- 첫 번째 테이블(oi1): "상품 1이 포함된 주문"을 찾는다
- 두 번째 테이블(oi2): "그 주문에 있는 다른 상품들"을 찾는다

#### 3단계: JOIN 조건

`oi1.order_id = oi2.order_id`로 연결하면 같은 주문번호를 가진 모든 상품 조합이 만들어진다.

#### 4단계: WHERE 필터링

- `oi1.product_id = 1` → oi1에서 상품 1이 있는 행만 남긴다
- `oi2.product_id != 1` → oi2에서 상품 1 자기 자신은 제외한다

이렇게 하면 "상품 1과 같은 주문에 있는, 상품 1이 아닌 다른 상품들"만 남는다.

#### 5단계: GROUP BY + COUNT

oi2의 상품별로 묶어서 몇 번 함께 구매됐는지 센다.

---

### 배운 점

1. **Self JOIN 용도**: 같은 테이블에서 서로 다른 행을 비교해야 할 때 사용
2. **별칭 구분**: oi1은 기준 상품 필터링용, oi2는 함께 구매된 상품 추출용
3. **자기 자신 제외**: `!= 1` 조건으로 기준 상품 자체는 결과에서 제외
